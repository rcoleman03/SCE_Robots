using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Windows.Forms;
using System.Xml;
using System.Xml.Linq;
using System.Net;
using System.IO.Compression;
using ICSharpCode.SharpZipLib;
using ICSharpCode.SharpZipLib.Core;
using ICSharpCode.SharpZipLib.Zip;
using System.Runtime.InteropServices;



namespace Dynamic.Script_8D654591CD4B967
{
	// Script generated by Pega Robotics Studio 8.0.1072.0
	// Please use caution when modifying class name, namespace or attributes
	[OpenSpan.TypeManagement.DynamicTypeAttribute()]
	[OpenSpan.Design.ComponentIdentityAttribute("Script-8D654591CD4B967")]
	public sealed class Script
	{
		public void URL_Download(string url, string localPath)
		{
			using (var client = new WebClient())
			{
				client.DownloadFile(url, localPath);
			}
		}

		public string GetReferenceDataValue(string filePath, string recordName)
		{
			XElement records = XElement.Load(filePath);
			XElement myRecord = records.Element(recordName);
			return myRecord.Value;
		}

		
		public void _CompressFolder(string path, ZipOutputStream zipStream, int folderOffset, string zipFileName)
		{
			string[] files = Directory.GetFiles(path);

			foreach (string filename in files)
			{
				if(filename != zipFileName)
				{
					FileInfo fi = new FileInfo(filename);
					string entryName = filename.Substring(folderOffset); // Makes the name in zip based on the folder
					entryName = ZipEntry.CleanName(entryName); // Removes drive from name and fixes slash direction
					ZipEntry newEntry = new ZipEntry(entryName);
					newEntry.DateTime = fi.LastWriteTime; // Note the zip format stores 2 second granularity
	
					// Specifying the AESKeySize triggers AES encryption. Allowable values are 0 (off), 128 or 256.
					// A password on the ZipOutputStream is required if using AES.
					//   newEntry.AESKeySize = 256;
	
					// To permit the zip to be unpacked by built-in extractor in WinXP and Server2003, WinZip 8, Java, and other older code,
					// you need to do one of the following: Specify UseZip64.Off, or set the Size.
					// If the file may be bigger than 4GB, or you do not need WinXP built-in compatibility, you do not need either,
					// but the zip will be in Zip64 format which not all utilities can understand.
					//   zipStream.UseZip64 = UseZip64.Off;
					newEntry.Size = fi.Length;
	
					zipStream.PutNextEntry(newEntry);
	
					// Zip the file in buffered chunks
					// the "using" will close the stream even if an exception occurs
					byte[ ] buffer = new byte[4096];
					using (FileStream streamReader = File.OpenRead(filename))
					{ StreamUtils.Copy(streamReader, zipStream, buffer); }
					zipStream.CloseEntry();
				}
			}
			string[] folders = Directory.GetDirectories(path);
			foreach (string folder in folders)
			{ _CompressFolder(folder, zipStream, folderOffset,zipFileName); }

		}

		public void UnzipFile(string zipFileName, string targetDir)
		{
		
			string script = "Unzip";
			try
			{
				OpenSpan.Diagnostics.Diagnostic.TraceVerbose("Script",string.Format("(0) ExecutionLink started", script));
				FastZip fastZip = new FastZip();
				string fileFilter = null;
				fastZip.ExtractZip(zipFileName,targetDir, fileFilter);
			}
			catch(Exception ex)
			{
				OpenSpan.Diagnostics.Diagnostic.PublishException(ex,null);
			}
			finally
			{
				OpenSpan.Diagnostics.Diagnostic.TraceVerbose("Script",string.Format("(0) ExecutionLink completed", script));
			}
		}

		public void UnzipFilePassword(string archiveFilenameIn, string password, string outFolder)
		{
		
			ZipFile zf = null;
			try {
				FileStream fs = File.OpenRead(archiveFilenameIn);
				zf = new ZipFile(fs);
				if (!String.IsNullOrEmpty(password)) {
					zf.Password = password;     // AES encrypted entries are handled automatically
				}
				foreach (ZipEntry zipEntry in zf) {
					if (!zipEntry.IsFile) {
						continue;           // Ignore directories
					}
					String entryFileName = zipEntry.Name;
					// to remove the folder from the entry:- entryFileName = Path.GetFileName(entryFileName);
					// Optionally match entrynames against a selection list here to skip as desired.
					// The unpacked length is available in the zipEntry.Size property.

					byte[] buffer = new byte[4096];     // 4K is optimum
					Stream zipStream = zf.GetInputStream(zipEntry);

					// Manipulate the output filename here as desired.
					String fullZipToPath = Path.Combine(outFolder, entryFileName);
					string directoryName = Path.GetDirectoryName(fullZipToPath);
					if (directoryName.Length > 0)
						Directory.CreateDirectory(directoryName);

					// Unzip file in buffered chunks. This is just as fast as unpacking to a buffer the full size
					// of the file, but does not waste memory.
					// The "using" will close the stream even if an exception occurs.
					using (FileStream streamWriter = File.Create(fullZipToPath)) {
						StreamUtils.Copy(zipStream, streamWriter, buffer);
					}
				}
			} finally {
				if (zf != null) {
					zf.IsStreamOwner = true; // Makes close also shut the underlying stream
					zf.Close(); // Ensure we release resources
				}
			}
		}

		public void ZipFile(string zipFileName, string password, string folderToZip)
		{
			string script = "Zip";
			try
			{
				OpenSpan.Diagnostics.Diagnostic.TraceVerbose("Script",string.Format("(0) ExecutionLink started", script));

				FileStream fsOut = File.Create(zipFileName);
				ZipOutputStream zipStream = new ZipOutputStream(fsOut);
	
				zipStream.SetLevel(3); //0-9, 9 being the highest level of compression
	
				zipStream.Password = password;  // optional. Null is the same as not setting. Required if using AES.
	
				// This setting will strip the leading part of the folder path in the entries, to
				// make the entries relative to the starting folder.
				// To include the full path for each entry up to the drive root, assign folderOffset = 0.
				int folderOffset = folderToZip.Length + (folderToZip.EndsWith("\\") ? 0 : 1);
	
				_CompressFolder(folderToZip, zipStream, folderOffset, zipFileName);
	
				zipStream.IsStreamOwner = true; // Makes the Close also Close the underlying stream
				zipStream.Close();
			}
			catch(Exception ex)
			{
				OpenSpan.Diagnostics.Diagnostic.PublishException(ex,null);
			}
			finally
			{
				OpenSpan.Diagnostics.Diagnostic.TraceVerbose("Script",string.Format("(0) ExecutionLink completed", script));
			}

		}
		// returns path of most recent item in downloads folder
		public string GetRecentDownload()
		{
			string downloads = KnownFolders.GetPath(KnownFolder.Downloads);
			var dir = new DirectoryInfo(downloads);
			var recentFile = dir.GetFiles().OrderByDescending(f => f.LastWriteTime).First();
			return recentFile.FullName;
		}

		public string DownloadsFolderPath(){
			return KnownFolders.GetPath(KnownFolder.Downloads);
		}

		//Updates the file at the given path with the given name
		public bool MoveFile(string sourcePath, string newPath)
		{
			try
			{
				File.Move(sourcePath, newPath);
				return true;
			}
			catch (Exception e)
			{
				Console.WriteLine("MoveFile failed: {0}", e.ToString());
				return false;
			}
		}
	}
}

/// <summary>
/// Class containing methods to retrieve specific file system paths.
/// </summary>
public static class KnownFolders
{
    private static string[] _knownFolderGuids = new string[]
    {
        "{56784854-C6CB-462B-8169-88E350ACB882}", // Contacts
        "{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}", // Desktop
        "{FDD39AD0-238F-46AF-ADB4-6C85480369C7}", // Documents
        "{374DE290-123F-4565-9164-39C4925E467B}", // Downloads
        "{1777F761-68AD-4D8A-87BD-30B759FA33DD}", // Favorites
        "{BFB9D5E0-C6A9-404C-B2B2-AE6DB6AF4968}", // Links
        "{4BD8D571-6D19-48D3-BE97-422220080E43}", // Music
        "{33E28130-4E1E-4676-835A-98395C3BC3BB}", // Pictures
        "{4C5C32FF-BB9D-43B0-B5B4-2D72E54EAAA4}", // SavedGames
        "{7D1D3A04-DEBB-4115-95CF-2F29DA2920DA}", // SavedSearches
        "{18989B1D-99B5-455B-841C-AB7C74E4DDFC}", // Videos
    };

    /// <summary>
    /// Gets the current path to the specified known folder as currently configured. This does
    /// not require the folder to be existent.
    /// </summary>
    /// <param name="knownFolder">The known folder which current path will be returned.</param>
    /// <returns>The default path of the known folder.</returns>
    /// <exception cref="System.Runtime.InteropServices.ExternalException">Thrown if the path
    ///     could not be retrieved.</exception>
    public static string GetPath(KnownFolder knownFolder)
    {
        return GetPath(knownFolder, false);
    }

    /// <summary>
    /// Gets the current path to the specified known folder as currently configured. This does
    /// not require the folder to be existent.
    /// </summary>
    /// <param name="knownFolder">The known folder which current path will be returned.</param>
    /// <param name="defaultUser">Specifies if the paths of the default user (user profile
    ///     template) will be used. This requires administrative rights.</param>
    /// <returns>The default path of the known folder.</returns>
    /// <exception cref="System.Runtime.InteropServices.ExternalException">Thrown if the path
    ///     could not be retrieved.</exception>
    public static string GetPath(KnownFolder knownFolder, bool defaultUser)
    {
        return GetPath(knownFolder, KnownFolderFlags.DontVerify, defaultUser);
    }

    private static string GetPath(KnownFolder knownFolder, KnownFolderFlags flags,
        bool defaultUser)
    {
        IntPtr outPath;
        int result = SHGetKnownFolderPath(new Guid(_knownFolderGuids[(int)knownFolder]),
            (uint)flags, new IntPtr(defaultUser ? -1 : 0), out outPath);
        if (result >= 0)
        {
            return Marshal.PtrToStringUni(outPath);
        }
        else
        {
            throw new ExternalException("Unable to retrieve the known folder path. It may not "
                + "be available on this system.", result);
        }
    }

    [DllImport("Shell32.dll")]
    private static extern int SHGetKnownFolderPath(
        [MarshalAs(UnmanagedType.LPStruct)]Guid rfid, uint dwFlags, IntPtr hToken,
        out IntPtr ppszPath);

    [Flags]
    private enum KnownFolderFlags : uint
    {
        SimpleIDList              = 0x00000100,
        NotParentRelative         = 0x00000200,
        DefaultPath               = 0x00000400,
        Init                      = 0x00000800,
        NoAlias                   = 0x00001000,
        DontUnexpand              = 0x00002000,
        DontVerify                = 0x00004000,
        Create                    = 0x00008000,
        NoAppcontainerRedirection = 0x00010000,
        AliasOnly                 = 0x80000000
    }
}

/// <summary>
/// Standard folders registered with the system. These folders are installed with Windows Vista
/// and later operating systems, and a computer will have only folders appropriate to it
/// installed.
/// </summary>
public enum KnownFolder
{
    Contacts,
    Desktop,
    Documents,
    Downloads,
    Favorites,
    Links,
    Music,
    Pictures,
    SavedGames,
    SavedSearches,
    Videos
}